$interFoamLES
stateType interFoamLES;

fieldMaps
{
    U U;
    p_rgh pmultiphase;
    alpha phase;
}

system
{
    fvSchemes
    {
        gradSchemes 
        {
            default              Gauss linear;
            grad(alpha.water) edgeCellsLeastSquares;
            turbulence      cellLimited leastSquares 1;
            grad(k)         edgeCellsLeastSquares;
            grad(omega)     edgeCellsLeastSquares;
            gradU           cellLimited Gauss linear 1;
            grad(p_rgh)     Gauss skewCorrected linear;
        }
        
        divSchemes
        {
            div(phi,k)      Gauss linearUpwind turbulence;
            div(phi,omega)  Gauss linearUpwind turbulence;
            div(phi,alpha)  Gauss vanLeer;
            div(phirb,alpha) Gauss linear;

            $fvSchemes_divSchemes_common       
        }

        $fvSchemes_misc
    }

    fvSolution
    {
        solvers 
        {
            "alpha.*"
            {
                nAlphaCorr      3;
                nAlphaSubCycles 1;
            }
            pcorr
            {
                solver PCG;
                preconditioner
                {
                    preconditioner GAMG;
                    tolerance 1e-06;
                    relTol 0.0;
                    smoother DICGaussSeidel;
                    nPreSweeps 0;
                    nPostSweeps 2;
                    nFinestSweeps 2;
                    cacheAgglomeration true;
                    nCellsInCoarsestLevel 100;
                    agglomerator faceAreaPair;
                    mergeLevels 1;
                }
                maxIter 100;
                minIter 1;
                tolerance 1e-6;
                relTol 0.0;
            }
            pcorrFinal
            {
                solver PCG;
                preconditioner
                {
                    preconditioner GAMG;
                    tolerance 1e-06;
                    relTol 0.0;
                    smoother DICGaussSeidel;
                    nPreSweeps 0;
                    nPostSweeps 2;
                    nFinestSweeps 2;
                    cacheAgglomeration true;
                    nCellsInCoarsestLevel 100;
                    agglomerator faceAreaPair;
                    mergeLevels 1;
                }
                maxIter 100;
                minIter 1;
                tolerance 1e-6;
                relTol 0.0;
            }
            p_rgh
            {
                #include "../settings/matrixSolvers/steadyGAMG.cfg"
            }
            p_rghFinal
            {
                vTol 1e-8;
                vRelTol 0.0;
                #include "../settings/matrixSolvers/PCGGAMG.cfg"
                #remove vTol
                #remove vRelTol
            }
            U{#include "../settings/matrixSolvers/steadySmoothSolver.cfg"}
            UFinal{#include "../settings/matrixSolvers/transientSmoothSolver.cfg"}        
        }
        PIMPLE
        {
            momentumPredictor yes;
            nCorrectors     3;
            nOuterCorrectors     1;
            nNonOrthogonalCorrectors 0;
            correctPhi      yes;
            moveMeshOuterCorrectors no;
            refineMeshOuterCorrectors no;
        }

        relaxationFactors 
        {
            equations
            {
                U               0.9;
            }
        }
        
        cache{grad(U);}
    }

    controlDict
    {
        application skaEcomarine;
        $controlDict_trans
        writeControl    adjustableRunTime;
        deltaT          0.001;
        writeInterval   0.1;
        
        adjustTimeStep 	yes;
        maxCo          	0.666;
		maxAlphaCo      0.333;
        maxDeltaT      	1.0;
    }


}

constant
{
    g{$g}                
}

fields
{
    U
    {
        allowedFieldInitialisationMethods (default fixedValue boundaryValue potentialFlow cellSet);
        initialisation {type default; priority 2;}
        solver smoothSolver;
        vRef uniform (0 0 0);

        fieldDefinition
        {
            type vector;
            dimensions [ 0 1 -1 0 0 0 0 ];
            internalField $vRef;

            boundaryTypeDefaults
            {
                wall {type wallVelocity; value $vRef;}
                mappedWall {type wallVelocity; value $vRef;}
                outlet {type inletOutlet; inletValue $vRef; value $vRef;}
                inlet {type fixedValueVelocity; value $vRef;}
                patch {type pressureInletOutletVelocity; value $vRef;}
                inactive {type fixedValueZone; value $vRef;}
                indirectWall {$wall}
                invisible {type zeroGradient;}
            }
            boundaryConditions
            {
            }
        }
        #remove vRef;
    }
}