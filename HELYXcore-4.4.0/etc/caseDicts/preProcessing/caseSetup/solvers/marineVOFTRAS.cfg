$segregatedVOFTRAS
stateType tHelyxSegregatedVOFRAS;

global
{
    system
    {
        controlDict
        {
            writeControl    adjustableRunTime;
            deltaT          0.001;
            writeInterval   0.1;

            adjustTimeStep 	yes;
            maxCo           20;
            maxAlphaCo      5;
            maxDeltaT       0.01;

            libs ( "libHelyxEcomarine.so" );
        }
    }
}

fieldMaps
{
    alpha phaseMarine;
}

system
{
    fvSchemes
    {
        gradSchemes
        {
            default         Gauss linear;
        }

        divSchemes
        {
            div(phi,k)      bounded Gauss linearUpwind turbulence;
            div(phi,omega)  bounded Gauss linearUpwind turbulence;
        }

        laplacianSchemes
        {
            laplacian((rho*DomegaEff),omega) Gauss linear limited 0.333;
        }
    }

    fvSolution
    {
        solvers
        {
            "alpha.*"
            {
                solver          smoothSolver;
                smoother        symGaussSeidel;
                tolerance       1e-10;
                relTol          0;
                nSweeps 		1;
                minIter 		1;
            }

            pFinal
            {
                vTol 1e-8;
                vRelTol 0.0;
                #include "../settings/matrixSolvers/PCGGAMG.cfg"
                #remove vTol
                #remove vRelTol
            }
        }
        PIMPLE
        {
            momentumPredictor yes;
            nCorrectors 3;
            nOuterCorrectors 1;
            nNonOrthogonalCorrectors 1;
            refineMeshOuterCorrectors no;
        }

        relaxationFactors
        {
            fields
            {
                p 1;
            }
            equations
            {
                U 1;
            }
        }
    }
    fvOptions
    {
        volumeFractionSolver
        {
            type MULESVolumeFractionSolver;

            nAlphaCorr      3;
            nAlphaSubCycles 1;
            cAlpha          1;

            MULESCorr       yes;
            nLimiterIter    50;

            alphaApplyPrevCorr	no;
            icAlpha             0;
        }
        waveSource
        {
            type waveSource;
        }
    }
}

fields
{
    U
    {
        allowedFieldInitialisationMethods (default fixedValue boundaryValue potentialFlow cellSet);
        initialisation {type default; priority 2;}
        solver smoothSolver;
        vRef uniform (0 0 0);

        fieldDefinition
        {
            type vector;
            dimensions [ 0 1 -1 0 0 0 0 ];
            internalField $vRef;

            boundaryTypeDefaults
            {
                wall {type wallVelocity; value $vRef;}
                mappedWall {type wallVelocity; value $vRef;}
                outlet {type inletOutlet; inletValue $vRef; value $vRef;}
                inlet {type fixedValueVelocity; value $vRef;}
                patch {type pressureInletOutletVelocity; value $vRef;}
                inactive {type fixedValueZone; value $vRef;}
                indirectWall {$wall}
                invisible {type zeroGradient;}
            }
            boundaryConditions
            {
            }
        }
        #remove vRef;
    }
    p
    {
        vRef uniform 0;

        fieldDefinition
        {
            boundaryTypeDefaults
            {
                outlet {type fixedprghPressure; p_rgh $vRef; value $vRef;}
            }
        }
        #remove vRef;
    }
    omega
    {
        omegaRef uniform 1;

        fieldDefinition
        {
            boundaryTypeDefaults
            {
                wall
                {
                    type omegaWallFunction;
                    value $omegaRef;
                }
                mappedWall {$wall}
                indirectWall {$wall}
            }
        }
        #remove omegaRef;
    }
    nut
    {
        nutRef uniform 0.001;

        fieldDefinition
        {
            boundaryTypeDefaults
            {
                wall
                {
                    type nutUSpaldingWallFunction;
                    value $nutRef;
                }
                mappedWall {$wall}
                indirectWall {$wall}
            }
        }
        #remove nutRef;
    }
}
