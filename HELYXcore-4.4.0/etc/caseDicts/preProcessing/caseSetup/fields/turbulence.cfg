baseTurb
{
    allowedFieldInitialisationMethods (default fixedValue boundaryValue Prandtl turbulentIL cellSet);
    initialisation{type turbulentIL; I 0.05; L 0.01; Uref 1;}
    solver smoothSolver;

    fieldDefinition
    {
        type scalar;
    }
}

k
{
    $baseTurb
    vRef uniform 0.1;
    
    fieldDefinition
    {
        dimensions [ 0 2 -2 0 0 0 0 ];
        internalField $vRef;

        boundaryTypeDefaults
        {
            mappedWall{type kqRWallFunction; value uniform 1e-20;}
            wall{type kqRWallFunction; value uniform 1e-20;}
	        outlet{type turbulentIntensityKineticEnergyInlet; intensity 0.05; value $vRef;} 
            inlet{type turbulentIntensityKineticEnergyInlet; intensity 0.05; value $vRef;} 
            patch{type turbulentIntensityKineticEnergyInlet; intensity 0.05; value $vRef;} 
            inactive {type fixedValueZone; value $vRef;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}
kCompressible
{
    $k
}
lowReK
{
    $k

    fieldDefinition
    {
        boundaryTypeDefaults
        {
            mappedWall{type kLowReWallFunction; value uniform 1e-20;}
            wall{type kLowReWallFunction; value uniform 1e-20;}
            indirectWall {$wall}
        }
        boundaryConditions
        {
        }
    }
}
lowReKCompressible
{
    $lowReK
}

qZetaK
{
    $lowReK
}

//***This entry needs to be reviewed - boundaryTypeDefaults
kEuler
{
    $k
    vRef uniform 0.1;
    allowedFieldInitialisationMethods (default fixedValue boundaryValue Prandtl cellSet);
    initialisation{type Prandtl;}


    fieldDefinition
    {
        boundaryTypeDefaults
        {
            mappedWall {type zeroGradient;}
            wall {type zeroGradient;}
            outlet{type inletOutlet; inletValue $vRef; value $vRef;}
            inlet{type fixedValue; value $vRef;}
            patch {type inletOutlet; inletValue $vRef; value $vRef;}
            indirectWall {$wall}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}


epsilon
{
    $baseTurb
    vRef uniform 0.01;

    fieldDefinition
    {
        dimensions [ 0 2 -3 0 0 0 0 ];
        internalField $vRef;

        boundaryTypeDefaults
        {
            wall {type epsilonWallFunction; value uniform 1e-7;}
            mappedWall {type epsilonWallFunction; value uniform 1e-7;}
            outlet {type turbulentMixingLengthDissipationRateInlet; mixingLength 0.01; value $vRef;}
            inlet {type turbulentMixingLengthDissipationRateInlet; mixingLength 0.01; value $vRef;}
            patch {type turbulentMixingLengthDissipationRateInlet; mixingLength 0.01; value $vRef;}
            inactive {type fixedValueZone; value $vRef;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}

epsilonCompressible
{
    $epsilon
}

lowReEpsilon
{
    $epsilon

    fieldDefinition
    {
        boundaryTypeDefaults
        {
            wall {lowReCorrection true;}
            mappedWall {lowReCorrection true;}
            indirectWall {$wall}
        }
        boundaryConditions
        {
        }
    }
}

lowReEpsilonCompressible
{
    $lowReEpsilon
}

qZetaEpsilon
{
    $lowReEpsilon
}

///*** the wall boundary conditions are likely incorrect
epsilonEuler
{
    $epsilon
    vRef uniform 0.01;
    allowedFieldInitialisationMethods (default fixedValue boundaryValue Prandtl cellSet);
    initialisation{type Prandtl;}

    fieldDefinition
    {
        boundaryTypeDefaults
        {
            wall {type zeroGradient;}
            mappedWall {type zeroGradient;}
            outlet {type inletOutlet; inletValue $vRef; value $vRef;}
            inlet {type fixedValue; value $vRef;}
            patch {type inletOutlet; inletValue $vRef; value $vRef;}
            indirectWall {$wall}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}

omega
{
    $baseTurb
    vRef uniform 0.01;

    fieldDefinition
    {
        dimensions [ 0 0 -1 0 0 0 0 ];
        internalField $vRef;

        boundaryTypeDefaults
        {
            wall {type omegaWallFunction; value uniform 1;}
            mappedWall {type omegaWallFunction; value uniform 1;}
            outlet {type turbulentMixingLengthFrequencyInlet; mixingLength 0.01; value $vRef;}
            inlet {type turbulentMixingLengthFrequencyInlet; mixingLength 0.01; value $vRef;}
            patch {type turbulentMixingLengthFrequencyInlet; mixingLength 0.01; value $vRef;}
            inactive {type fixedValueZone; value $vRef;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}

omegaCompressible
{
    $omega
}

omegaKnopCompressible
{
    $omegaCompressible

    fieldDefinition
    {
        boundaryTypeDefaults
        {
            wall {type knopOmegaWallFunction; value uniform 1;}
            mappedWall {type knopOmegaWallFunction; value uniform 1;}
        }
    }
}

nuTilda
{
    $baseTurb
    vRef uniform 0.001;

    fieldDefinition
    {
        dimensions [ 0 2 -1 0 0 0 0 ];
        internalField $vRef;

        boundaryTypeDefaults
        {
            wall {type fixedValue; value uniform 0;}
            mappedWall {type fixedValue; value uniform 0;}
            outlet {type nutTurbulentIntensityLengthScaleInlet; length 0.01; intensity 0.01; value $vRef;}
            inlet {type nutTurbulentIntensityLengthScaleInlet; length 0.01; intensity 0.01; value $vRef;}
            patch {type nutTurbulentIntensityLengthScaleInlet; length 0.01; intensity 0.01; value $vRef;}
            inactive {type fixedValueZone; value $vRef;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}

f
{
    vRef uniform 1e-10;
    allowedFieldInitialisationMethods (default fixedValue cellSet);
    initialisation{type fixedValue; value $vRef;}
    solver smoothSolver;

    fieldDefinition
    {
        type scalar;
        dimensions [0 0 -1 0 0 0 0];
        internalField $vRef;

        boundaryTypeDefaults
        {
            wall {type fWallFunction; value $vRef;}
            mappedWall {type fWallFunction; value $vRef;}
            outlet {type zeroGradient;}
            inlet {type zeroGradient;}
            patch {type zeroGradient;}
            inactive {type fixedValueZone; value $vRef;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}

fCompressible
{
    $f
}

a
{
    vRef uniform 0.5;
    allowedFieldInitialisationMethods (default fixedValue cellSet);
    initialisation{type fixedValue; value $vRef;}
    solver smoothSolver;

    fieldDefinition
    {
        type scalar;
        dimensions [0 0 0 0 0 0 0];
        internalField $vRef;

        boundaryTypeDefaults
        {
            wall {type aWallFunction; value uniform 1e-10;}
            mappedWall {type aWallFunction; value uniform 1e-10;}
            outlet {type fixedValue; value uniform 1;}
            inlet {type fixedValue; value uniform 1;}
            inactive {type fixedValueZone; value uniform 1e-10;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}

v2
{
    vRef uniform 1e-10;
    allowedFieldInitialisationMethods (default fixedValue cellSet);
    initialisation{type fixedValue; value $vRef;}
    solver smoothSolver;

    fieldDefinition
    {
        type scalar;
        dimensions [0 2 -2 0 0 0 0];
        internalField uniform 1e-3;

        boundaryTypeDefaults
        {
            wall {type v2WallFunction; value $vRef;}
            mappedWall {type v2WallFunction; value $vRef;}
            outlet {type inletOutlet; inletValue $vRef; value $vRef;}
            inlet {type fixedValue; value uniform 1e-3;}
            patch {type inletOutlet; inletValue $vRef; value $vRef;}
            inactive {type fixedValueZone; value $vRef;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}

v2Compressible
{
    $v2
}

v2k
{
    $baseTurb
    vRef uniform 0.6667;
    allowedFieldInitialisationMethods (default fixedValue cellSet);
    initialisation{type fixedValue; value $vRef;}
    solver smoothSolver;

    fieldDefinition
    {
        type scalar;
        dimensions [0 0 0 0 0 0 0];
        internalField $vRef;

        boundaryTypeDefaults
        {
            wall {type v2kWallFunction; value $vRef;}
            mappedWall {type v2kWallFunction; value $vRef;}
            outlet {type zeroGradient;}
            inlet {type fixedValue; value $vRef;}
            patch {type inletOutlet; inletValue $vRef; value $vRef;}
            inactive {type fixedValueZone; value $vRef;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}

kl
{
    allowedFieldInitialisationMethods (default fixedValue cellSet);
    initialisation{type fixedValue; value uniform 1e-10;}
    solver smoothSolver;

    fieldDefinition
    {
        type scalar;
        dimensions [0 2 -2 0 0 0 0];
        internalField uniform 1e-10;

        boundaryTypeDefaults
        {
            mappedWall {type fixedValue; value uniform 1e-20;}
            wall {type fixedValue; value uniform 1e-20;}
            outlet {type inletOutlet; inletValue uniform 1e-20; value uniform 1e-20;}
            inlet {type fixedValue; value uniform 1e-20;}
            patch {type inletOutlet; inletValue uniform 1e-20; value uniform 1e-20;}
            inactive {type fixedValueZone; value uniform 1e-20;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
}

kt
{
    allowedFieldInitialisationMethods (default fixedValue cellSet);
    initialisation{type fixedValue; value uniform 1e-10;}
    solver smoothSolver;

    fieldDefinition
    {
        type scalar;
        dimensions [0 2 -2 0 0 0 0];
        internalField uniform 1e-10;

        boundaryTypeDefaults
        {
            wall {type fixedValue; value uniform 1e-10;}
            mappedWall {type fixedValue; value uniform 1e-10;}
            outlet {type inletOutlet; inletValue uniform 0; value uniform 0;}
            inlet {type fixedValue; value uniform 0;}
            patch {type inletOutlet; inletValue uniform 0; value uniform 0;}
            inactive {type fixedValueZone; value uniform 1e-20;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
}

kklomega
{
    allowedFieldInitialisationMethods (default fixedValue);
    initialisation{type fixedValue; value uniform 1e-10;}
    solver smoothSolver;

    fieldDefinition
    {
        type scalar;
        dimensions [ 0 0 -1 0 0 0 0 ];
        internalField uniform 1e-10;

        boundaryTypeDefaults
        {
            mappedWall {type zeroGradient;}
            wall {type zeroGradient;}
            outlet {type inletOutlet; inletValue uniform 0; value uniform 0;}
            inlet {type fixedValue; value uniform 0;}
            patch {type inletOutlet; inletValue uniform 0; value uniform 0;}
            inactive {type fixedValueZone; value uniform 0;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
}
	
R
{
    
    allowedFieldInitialisationMethods (default fixedValue);
    initialisation{type fixedValue; value uniform (0 0 0 0 0 0);}
    solver smoothSolver;

    vRef uniform (0.1 0.1 0.1 0.1 0.1 0.1);	
    
    fieldDefinition
    {	
        type symmTensor;
        dimensions [ 0 2 -2 0 0 0 0 ];
    	internalField $vRef;	


        boundaryTypeDefaults
        {
	        mappedWall{type kqRWallFunction; value uniform (0 0 0 0 0 0);}
            wall{type kqRWallFunction; value uniform (0 0 0 0 0 0);}
	        outlet{type turbulentIntensityReynoldsStressInlet; intensity 0.05; value $vRef;}
	        inlet {type turbulentIntensityReynoldsStressInlet; intensity 0.05; value $vRef;}
	        patch {type turbulentIntensityReynoldsStressInlet; intensity 0.05; value $vRef;}
            inactive {type fixedValueZone; value $vRef;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
    #remove vRef;
}

RCompressible
{
    $R
}	

ReThetat
{
    
    allowedFieldInitialisationMethods (default fixedValue);
    initialisation{type fixedValue; value uniform 0.0;}
    solver smoothSolver;

    fieldDefinition
    {	
        type scalar;
        dimensions [ 0 0 0 0 0 0 0 ];
    	internalField uniform 0.0;	

        boundaryTypeDefaults
        {
            mappedWall{type zeroGradient;}
            wall{type zeroGradient;}
            outlet{type zeroGradient;}
            inlet {type fixedValue; value uniform 0.0;}
            patch {type zeroGradient;}
            inactive {type fixedValueZone; value uniform 0.0;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
}

ReThetatCompressible
{
    $ReThetat
}

gammaInt
{
    
    allowedFieldInitialisationMethods (default fixedValue);
    initialisation{type fixedValue; value uniform 1.0;}
    solver smoothSolver;

    fieldDefinition
    {	
        type scalar;
        dimensions [ 0 0 0 0 0 0 0 ];
    	internalField uniform 1.0;	

        boundaryTypeDefaults
        {
            mappedWall{type zeroGradient;}
            wall{type zeroGradient;}
            outlet{type zeroGradient;}
            inlet {type fixedValue; value uniform 1.0;}
            patch {type zeroGradient;}
            inactive {type fixedValueZone; value uniform 1.0;}
            indirectWall {$wall}
            invisible {type zeroGradient;}
        }
        boundaryConditions
        {
        }
    }
}

gammaIntCompressible
{
    $gammaInt
}

#remove baseTurb;
