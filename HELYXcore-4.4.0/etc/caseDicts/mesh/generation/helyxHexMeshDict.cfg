/*--------------------------------*- C++ -*----------------------------------*\
|       o        |                                                            |
|    o     o     |  HELYX (R) : Open-source CFD for Enterprise                |
|   o   O   o    |  Version : 4.4.0                                           |
|    o     o     |  ENGYS Ltd. <http://engys.com/>                            |
|       o        |                                                            |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      helyxHexMeshDict.cfg;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

castellatedMesh true;
snap            true;
addLayers       true;

//Whether to run standard/extrude/dual algorithm
meshAlgorithm standard;

//Use OpenVDB to generate castellated mesh
// voxelSize is specified with blockData
VDBrefinement   false;

VDBdomain
{
    //boundingBox in axis-aligned global coordinates
    min ( -5 -4  0 );
    max ( 15  4  8 );

    //scaleVoxel (1.5 1 1);

    //coordinateSystem
    //{
    //    type            cartesian;
    //    origin          ( 0 0 0 );
    //    //15 deg yaw
    //    e1              ( 0.9659 0.2588 0 );
    //    e2              ( 0.2588 0.9659 0 );

    //    yawPitchRoll    (15 0 0);
    //    //rollPitchYaw    (0 0 15);
    //}

    patches
    {
        //xmin {type wall;     name inlet;   }
        //xmax {type wall;     name outlet;  }
        ymin {type symmetry; name symmetry;}
        //ymax {type wall;     name sidewall;}
        zmin {type wall;     name ground;  }
        //zmax {type wall;     name top;     }
    }

    writeGrids      false;
}


//Which meshing workflow to use (options: quality, balanced, fast, dryrun)
meshMode quality;

// For meshing internal geometry, autoBlockMesh can be set to true
autoBlockMesh false;
blockData (0.01 0);  // used also for VDBrefinement, e.g. 0.01 voxelSize al cellLevel 0
// setting true forces isotropic auto block mesh cells
blockIso false;
// Optional change to auto block origin location
//blockOrigin ( 0 0 0);

//Create surface field of the shell level for faster refinement lookup
cacheShellLevel true;

//Optional overwrite of level 0 length scale (negative to disable)
//manualLevel0EdgeLength -1000;

// Whether to allow small crack closure method and tolerance used
crackDetection false;
crackTol 0.05;

// Whether to allow topology changes during snapping to maintain hex split-hex
// cells
allowTopoChanges true;

// Convert surfaces to single region if contain more than this number of regions
maxRegionSize 100000;

//Allow list of alternative triSurface folders to be searched
//alternativeSurfacePath ( "<path/to/triSurface>" );

//Final decomposition method to perform at the end of mesh generation
finalDecomposition ptscotch;

geometry
{
}

castellatedMeshControls
{
    features
    (
    );

    refinementSurfaces
    {
    }

    refinementRegions
    {
    }

    // Refinement parameters
    // ~~~~~~~~~~~~~~~~~~~~~

    // While refining maximum number of cells per processor. This is basically
    // the number of cells that fit on a processor. If you choose this too small
    // it will do just more refinement iterations to obtain a similar mesh.
    maxLocalCells 250000000;

    // Overall cell limit (approximately). Refinement will stop immediately
    // upon reaching this number so a refinement level might not complete.
    // Note that this is the number of cells before removing the part which
    // is not 'visible' from the keepPoint. The final number of cells might
    // actually be a lot less.
    maxGlobalCells 1000000000;

    // The surface refinement loop might spend lots of iterations refining just a
    // few cells. This setting will cause refinement to stop if <= minimumRefine
    // are selected for refinement. Note: it will at least do one iteration
    // (unless the number of cells to refine is 0)
    minRefinementCells 100;

    // Allow a certain level of imbalance during refining
    // (since balancing is quite expensive)
    // Expressed as fraction of perfect balance (= overall number of cells /
    // nProcs). 0=balance always.
    maxLoadUnbalance 0.10;

    // Number of buffer layers between different levels.
    // 1 means normal 2:1 refinement restriction, larger means slower
    // refinement.
    nCellsBetweenLevels 2;

    //Optional closing of single cell gaps
    singleCellGapClosure false;

    //Optional wrapping at specified level
    wrapLevel -1;

    // Resolve sharp angles
    resolveFeatureAngle -60.;
    featureRefineAngle 20.;
    refineSurfaceBoundary false;

    //Refinement based on tri-surface curvature field (degrees)
    curvature -1;

    //Can be set global, surface or region basis, to remove
    //individual baffle faces not aligned with the surface by this angle
    minBaffleAngle -60;

    // Are zone faces allowed only inbetween different cell zones
    // or also just free standing?
    allowFreeStandingZoneFaces false;

    // Perform balancing before refinement
    balanceThenRefine true;

    // Perform gap refinement iterations
    nGapRefinements 0;

    // Remove small disconnected regions from zone
    minZoneRegionSize 1;

    // Whether to perform additional inside check for shell refinement
    additionalInsideCheck false;

    // Whether for intersection checking to perturb cell centroids sitting
    // exactly on surface geometry. Perturbation is made in surface normal
    // direction by amount specified by keyword (-1 to diable)
    moveCentroidsTol -1;

    wrapper
    {
        // Switch on/off wrapper (default off)
        wrap false;

        // Flow outlet patches need to be defined using outlets keyword
        // if outlets keyword is not specified picks up blockMesh boundaries
        outlets (inlet outlet ffmaxy ffminy ffmaxz ffminz);

        // Two mechanisms for excluding regions 1) list of exclusion
        //  points or 2) global cutoff (default).

        //excludePoints ((0.0 0.0 0.5));
        cutoff 1000.;

        // standard deviation used
        sigma 3.0;

        // Default is to use volume sources where cells within a distance
        // (set by volDistance) of non outlet patches are seeded with
        // volumetric sources
        volSources true;
        volDistance 1.0;

        // adjust porosity and volumetric source strength to allow cutoff
        // to be consistently set
        meshInMM false;

        // Maximum number of solver iteration to perform
        maxIter 200;

        // Write wrapper debug
        writeFields false;

        // Invert cells for removal
        invert false;
    }

}


snapControls
{
    featureEdges
    {
    }

    //- Set number of outer feature snapping iterations
    nOuterIter 1;

    //- Set number of pre feature snapping iterations
    nPreFeatureIter 0;

    //- Set number of displacement smoothing iterations
    nSolveIter 10;

    //- Set number of main feature snapping iterations
    nFeatureIter 60;

    //- Switch for performing global feature snapping
    globalFeatureEdges true;

    // Set direct snapping for region boundaries globally
    globalRegionSnap false;

    //- Number of patch smoothing iterations before finding correspondence
    //  to surface
    nSmoothPatch 2;

    //- Relative distance for points to be attracted by surface feature point
    //  or edge. True distance is this factor times local
    //  maximum edge length.
    tolerance 4.0;

    //- Maximum number of snapping relaxation iterations. Should stop
    //  before upon reaching a correct mesh.
    nRelaxIter 5;

     //Perform feature snapping for zoned surfaces
    zoneFeatureSnapping true;

     //snapping directly to geometric and region feature lines
    directFeatureSnapping true;

    // Set direct snapping for geometric feature lines
    geometryFeatureLines true;

    // Set tolerance for edge collapsing (-1 to disable)
    collapseTol 0.25;

    // Switch to enable smoothing of surface during feature snapping
    smoothSnappedSurface true;

    // Additional projection to the surface to obtain the average surface normal
    averageSurfaceNormal true;

    // Enlarge stencil used for surface search. Set to false
    // for faster feature snapping
    enlargeStencil false;

    // Perform mesh quality checks during snapping to disable motion
    // when errors are introduced. Set to false for faster feature snapping
    featureSnapChecks true;

    // Tolerance used to remove concavity in face (fraction of face area)
    // Set negative to disable
    concaveTol 0.3;

    // Smooth small triangular faces that might beformed during snapping
    // to feature lines
    nSliverSmooths 10;

    // Whether to merge boundary faces
    mergeBoundaryFaces true;

    // Relaxed patch regioning if set to true
    mergeAcrossPatches false;

    // Detect overlapping patches and set minimum patch ID
    repatchOverlapping false;

    // Write out intermediate snap stages
    writeSnapVTK false;

    //Pre smooth nodes adjacent to baffle edges
    preSmoothAtBaffleEdges false;
}

addLayersControls
{
    layers
    {
    }

    // Whether to use relative or absolute sizing for layer addition
    relativeSizes true;

    // Expansion factor for layer mesh
    expansionRatio 1.25;

    //- Wanted thickness of final added cell layer. If multiple layers
    //  is the
    //  thickness of the layer furthest away from the wall.
    //  Relative to undistorted size of cell outside layer.
    finalLayerThickness 0.4;

    //- Minimum thickness of cell layer. If for any reason layer
    //  cannot be above minThickness do not add layer.
    //  Relative to undistorted size of cell outside layer.
    minThickness 0.2;

     // Advanced settings

    // Terminate layers at feature edges specified with this angle (0 to disable)
    featureAngleTerminate 80;

    //- Maximum number of snapping relaxation iterations. Should stop
    //  before upon reaching a correct mesh.
    nRelaxIter 5;

    // Stop layer growth on highly warped cells
    maxFaceThicknessRatio 2.0;

    // Reduce layer growth where ratio thickness to medial
    // distance is large
    maxThicknessToMedialRatio 0.3;

    // Angle used to pick up medial axis points
    minMedialAxisAngle 90;

    // Maximum number of layer generation iterations
    maxLayerIter  30;

    // Try and grow around convex edges
    growConvexEdge true;

    // Try and grow around concave edges
    growConcaveEdge true;

    // Try to grow layers up non grown planar surfaces (inlets, symmetry etc)
    growUpPatches true;

    // Whether to re-balance based on predicted number of layer cells
    rebalance false;

    // Where layers collapse recover layers by this increment
    layerRecovery 1;

    // Smooth layer thickness over surface patches
    nSmoothThickness 10;

    // Smooth surface normals
    nSmoothSurfaceNormals 6;

    // Smooth interior normals
    nSmoothNormals 3;

    // Maximum distance layers can be projected
    maxProjectionDistance 10000;

    // Switch off projection where mesh displacement is this
    // multiple of the cell size
    maxCellDistortion 50;

    // Integer used to raise smoothing function to this power
    medialRatioExp 1;

    // Whether or not to collapse layers at zone interfaces
    growZoneLayers false;

    // set vtk output of layer additions
    writeVTK true;

    //Explicit forcing of first cell height
    fixedFCH false;

    //If set to positive value forces re-projection onto grown up surfaces
    projectGrownUp 0.0;

    //Dual mesh layer control

    // Angle to force collapse of layers around concave edges
    dualConcaveCollapse 0.0;

    // Smoothing weights at interface between layer and non-layer cells
    dualLayerInterfaceWeights 0.5;

    // Restrict grwoth of layers at zone interfaces
    dualZoneLayersScaling 1.0;

    // Stop layer projection when orthogonality is greater than specified value
    dualMaxOrtho 180;

    // Allow re-snapping onto zoned surfaces during layer projection
    dualReSnapZones true;

}


meshQualityControls
{
    //- Maximum non-orthogonality allowed. Set to 180 to disable.
    maxNonOrtho 70;

    //- Additional non-orthogonlaity check using face centres.
    // Set to 180 to disable
    maxFaceCentreNonOrtho 180;

    //- Max skewness allowed. Set to <0 to disable.
    maxBoundarySkewness 20;
    maxInternalSkewness 6;

    //- Max concaveness allowed. Is angle (in degrees) below which concavity
    //  is allowed. 0 is straight face, <0 would be convex face.
    //  Set to 180 to disable.
    maxConcave 80;

    //- Minimum projected area v.s. actual area. Set to -1 to disable.
    minFlatness 0.5;

    //- Minimum pyramid volume. Is absolute volume of cell pyramid.
    //  Set to very negative number (e.g. -1E30) to disable.
    minVol 1e-16;

    //- Minimum quality of the tet formed by the face-centre
    //  and variable base point minimum decomposition triangles and
    //  the cell centre. This has to be a positive number for tracking
    //  to work. Set to very negative number (e.g. -1E30) to
    //  disable.
    //     <0 = inside out tet,
    //      0 = flat tet
    //      1 = regular tet
    minTetQuality -1e30;//1e-30;

    //- Minimum face area. Set to <0 to disable.
    minArea 1e-13;

    //- Minimum face edge length. set to <0 to disable
    minEdgeLength -1;

    //- Minimum face twist. Set to <-1 to disable. dot product of face normal
    //- and face centre triangles normal
    minTwist 0.05;

    //- minimum normalised cell determinant
    //- 1 = hex, <= 0 = folded or flattened illegal cell
    minDeterminant 0.0001;

    //- minFaceWeight (0 -> 0.5)
    minFaceWeight 0.08;

    //- minVolRatio (0 -> 1)
    minVolRatio 0.02;

    //must be >0 for Fluent compatibility
    minTriangleTwist -0.99;

    // Advanced

    //- Number of error distribution iterations
    nSmoothScale 10;
    //- amount to scale back displacement at error points
    errorReduction 0.75;

    //- keep cells where collapsed volume ratio above this value
    minVolCollapseRatio -1;

    //Check for poorly connected cells
    faceFaceCells false;

    // Monitor cell volume during snapping so ratio of cell volume to
    //undistorted cell volume cannot fall below this ratio
    minSnapRelativeVolume -1;

    // same as minSnapRelativeVolume but for tetrahedral cells only
    minSnapRelativeTetVolume -1;

    // Check distance from gauss-green cell centre
    // to geometric cell centre relative to the undistorted cell size
    maxGaussGreenCentroid -1;

    // Perform additional orthogonality check based on cell-centre
    // to face-centre vector
    maxFaceCentreNonOrtho 180;

    // Perform checks of cell aspect ratio (For unit cube AR=1.732)
    // AR calculated as max to min of following distances
    // - Distance from cell centroid to face centre dotted with face normal
    // - Distance between cell centroid and cell nodes
    // Set to -1 to disable checks
    maxCellAspectRatio -1;

    // Perform relative volume/face area/edge length checks during snapping
    relativeVol -1;
    relativeFaceArea -1;
    relativeEdgeLength -1;

    //- project and smooth point edges which are closely aligned
    smoothAlignedEdges false;
}

// Advanced

// Flags for optional output
// 0 : only write final meshes
// 1 : write intermediate meshes
// 2 : write volScalarField with cellLevel for postprocessing
// 4 : write current intersections as .obj files
debug 0;

// Merge tolerance. Is fraction of overall bounding box of initial mesh.
// Note: the write tolerance needs to be higher than this.
mergeTolerance 1E-6;
